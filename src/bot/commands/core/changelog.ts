import { Command, Input } from '@api';
import { Framework } from '@core/framework';
import * as fs from 'fs';
import { Emoji } from '@bot/libraries/emoji';
import { RichEmbed } from 'discord.js';
import * as moment from 'moment';

export class Changelog extends Command {
    constructor() {
        super({
            name: 'changelog',
            aliases: ['version'],
            description: 'Shows the bot\'s current version along with a detailed changelog.'
        });
    }

    async execute(input: Input) {
        let changelogFilePath = root('changelog.json');

        // Error if there is no changelog file
        // Note: This file is auto-generated by the cloud container, so it won't be present on local test bots
        if (!fs.existsSync(changelogFilePath)) {
            return await input.channel.send(`${Emoji.ERROR}  No changelog is available at this time.`);
        }

        // Parse the data
        let data = JSON.parse(fs.readFileSync(changelogFilePath).toString()) as ChangelogSchema;
        let description = '';
        let fields : any[] = [];

        // Add a link to the release
        fields.push({
            name: 'Link',
            value: `https://github.com/baileyherbert/tau/releases/tag/${data.tag}` + '\n\u200b'
        });

        // Add the publish date in the form of time ago
        fields.push({
            name: 'Released',
            value: moment(data.timestamp).fromNow().capitalize() + '\n\u200b'
        });

        // Parse the body to extract the description and actual changes
        let lines = data.body.split(/(\r?\n)+/);
        let section : any = null;

        lines.forEach(line => {
            line = line.trim();

            if (line.startsWith('**')) {
                let title = line.match(/\*\*(.+)\*\*/)![1];

                if (section) {
                    section.value += '\n\u200b';
                    fields.push(section);
                }

                section = {
                    name: title,
                    value: ''
                };
            }
            else {
                if (section) {
                    if (/^\s*-\s+(.+)$/.test(line)) {
                        let item = line.match(/^\s*-\s+(.+)$/)![1];
                        section.value += `\n•  ${item}`;
                        section.value = section.value.trimLeft();
                    }
                }
                else {
                    description += `\n${line}`;
                    description = description.trimLeft();
                }
            }
        });

        // Add the final section if applicable
        if (section) {
            section.value += '\n\u200b';
            fields.push(section);
        }

        // Send the embed in output
        await input.channel.send(new RichEmbed({
            description: description.trim() + '\n\u200b',
            color: 0x1c7ed6,
            timestamp: moment(data.timestamp).toDate(),
            author: { name: `Version ${data.name}` },
            fields: fields
        }));
    }
}

type ChangelogSchema = {
    tag: string;
    name: string;
    timestamp: number;
    body: string;
}
